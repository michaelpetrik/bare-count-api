name: Deploy Counter API to VPS

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      SSH_PORT: 2222
      TARGET_DIR: mini-counter-api

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Sync files to VPS
        run: |
          rsync -avz \
          --exclude '.git' \
          --exclude '.cursor' \
          --exclude '.github' \
          --exclude 'README.md' \
          --exclude 'API-DOCUMENTATION.md' \
          --exclude 'ENTERPRISE-DEPLOYMENT.md' \
          --exclude 'TRACKER-README.md' \
          --exclude 'DOCKER-README.md' \
          --exclude 'node_modules' \
          --exclude '.DS_Store' \
          --exclude '.vscode' \
          --exclude '__tests__' \
          --exclude 'tsconfig.json' \
          --exclude 'package-lock.json' \
          --delete \
          -e "ssh -p $SSH_PORT -o StrictHostKeyChecking=no" \
          ./ ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/home/${{ secrets.VPS_USER }}/$TARGET_DIR

      - name: Deploy Counter API on VPS
        run: |
          ssh -p $SSH_PORT -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          cd ~/${{ env.TARGET_DIR }}

          # Check .env exists (create from template only on first deployment)
          if [ ! -f .env ]; then
            cp env.example .env
            echo "‚ö†Ô∏è Created .env from template - CONFIGURE IT BEFORE NEXT DEPLOYMENT!"
            echo "üîß Edit .env file with your actual values and run deployment again."
            exit 1
          else
            echo "‚úÖ .env file exists - using existing configuration"
          fi

          # Make deploy script executable
          chmod +x deploy.sh

          # Stop existing containers
          docker compose down || true

          # Clean up old images to save space
          docker image prune -f

          # Deploy with rebuild to use updated code and env
          ./deploy.sh start

          # Show final status
          echo "=== Deployment Status ==="
          docker compose ps
          docker stats counter-api --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}" || true

                              # Quick health check with more time for startup
          echo "‚è≥ Quick health check..."
          sleep 30

          HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' counter-api 2>/dev/null || echo "unknown")
          API_PORT=$(grep "PORT=" .env | cut -d'=' -f2 || echo "3000")

          if [ "$HEALTH_STATUS" = "healthy" ]; then
            echo "‚úÖ Counter API container is healthy on port ${API_PORT}!"
          else
            echo "‚ùå Counter API health check failed! Status: ${HEALTH_STATUS}"
            echo "üîç Container logs:"
            docker compose logs counter-api --tail=10
            echo "üîç Health check logs:"
            docker inspect --format='{{range .State.Health.Log}}{{.Output}}{{end}}' counter-api 2>/dev/null || echo "No health logs available"
            exit 1
          fi
          EOF

      - name: Verify deployment
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "üìä API should be available at: https://${{ secrets.API_DOMAIN }}"
          echo "üìà Tracker: https://${{ secrets.API_DOMAIN }}/tracker.js"

          # External health check through Traefik
          echo "üîç Testing external API endpoint..."
          sleep 5
          if curl -f -s "https://${{ secrets.API_DOMAIN }}/health" > /dev/null; then
            echo "‚úÖ External API endpoint is reachable through Traefik!"
          else
            echo "‚ö†Ô∏è External endpoint not yet available (DNS/SSL might be propagating)"
            echo "üîß Check manually: https://${{ secrets.API_DOMAIN }}/health"
          fi

          echo "üîç Check status: ssh -p $SSH_PORT ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} 'cd $TARGET_DIR && docker compose ps'"
